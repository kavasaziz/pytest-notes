#+title: pytest
#+startup: show2levels

* Pytest Testing Framework
** Table of Contents :TOC:
- [[#pytest-testing-framework][Pytest Testing Framework]]
  - [[#installation][Installation]]
  - [[#pytest-introduction][PyTest Introduction]]
  - [[#test-searching][Test Searching]]
  - [[#save-time-and-code-with-test-fixtures][Save Time and Code with Test Fixtures]]
  - [[#basics-of-reporting-test-results-and-tracking-test-history][Basics of Reporting Test Results and Tracking Test History]]
  - [[#customizing-test-runs-with-the-command-line-and-configuration-files][Customizing Test Runs with the Command Line and Configuration Files]]
  - [[#handling-skips-and-expected-failures][Handling Skips and Expected Failures]]
  - [[#cross-browser-and-data-driven-testing-with-parametrize][Cross-Browser and Data-driven testing with parametrize]]
  - [[#fast-testing-with-pytest-xdist-and-parallel-vs-concurrent][Fast Testing with Pytest-xdist, and Parallel vs Concurrent]]
  - [[#writing-unit-tests-white-box-testing-with-tox][Writing Unit Tests (White Box Testing) with Tox]]
  - [[#writing-functional-tests-blackgrey-box-testing][Writing Functional Tests (Black/Grey Box Testing)]]

** Installation
Brief instructions on how to install the packages required for this repository on a Debian-based system are given below:

1. Update your package manager and install virtual environment for python.
  #+begin_src shell :shebang #!/usr/bin/env bash :results output
sudo apt-get update
sudo apt-get install python3-venv
  #+end_src

2. Upgrade the pip.
  #+begin_src shell :shebang #!/usr/bin/env bash :results output
python3 -m pip install --upgrade pip
  #+end_src

3. I will place my repository inside ~${HOME}/venvs/frameworkenv/~ folder. Therefore, create virtual environment inside this file.
  #+begin_src shell :shebang #!/usr/bin/env bash :results output
cd ~/venvs/frameworkenv/
python -m venv ./venv
  #+end_src

4. Activate virtual environment and install ~pytest~.
  #+begin_src shell :shebang #!/usr/bin/env bash :results output :dir ~/venvs/frameworkenv/
source ./bin/activate
python -m pip install pytest
  #+end_src

5. To quit from virtaul env just use ~deactivate~ command.
  #+begin_src shell :shebang #!/usr/bin/env bash :results output :dir ~/venvs/frameworkenv/
deactivate
  #+end_src

6. (Extra) To see the list of installed packages, you can use ~pip list~ or ~pip freeze~.
  #+begin_src shell :shebang #!/usr/bin/env bash :results output :dir ~/venvs/frameworkenv/
pip list 2>&1
pip freeze # This can be used to generate requirements.txt file also
  #+end_src

If you are facing another issue about management of python packges see more about python package management guide [[https://packaging.python.org/en/latest/guides/installing-using-pip-and-virtual-environments/][here]].
** PyTest Introduction
Test searching patterns of pytest is defined under =pytest.ini= file. The default patters are given below:
#+name: sample-[[pytest]]-ini
#+begin_src toml
[pytest]
python_files = test_*
python_classes = *Tests
python_functions = test_*
#+end_src

From those we can say that
- ~test_widget.py~ called files will be selected
- ~WidgetTests~ called class will be selected
- ~test_widget_click~ called function will be selected

To run tests just use ~pytest~ (add ~-v~ to have verbose output)
#+begin_src shell :shebang #!/usr/bin/env bash :results output
pytest -v
#+end_src

** Test Searching
Most common issue about test suites is that they require significant code refactoring when you want to create a new test suites, such as regression suite, smoke suit and unittest suite. This is caused since test file and test functions placement of tests are made for the suite. Therefore, for each suit, you will need to make a lot of copy paste, and which will make your suite and code hard to maintain.

Besides, it is not also easy to find location of the test under such a big code stack. Therefore, devide your test files and functions under more related units. For instance, if you see a failing test called ~test_ui_open~ you can easily that, it should be inside =entertainment= folder.
#+begin_example
.
├── pytest.ini
├── venv
└── tests
    └── sportscar
        ├── body
        ├── engine
        └── entertainment
#+end_example

Lets create quick fake tests files
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/tests/sportscar :results output
for file in $(ls); do touch $file/test_$file.py ; done
#+end_src

and some fake tests:
- body
  #+begin_src python
def test_body_functions_as_expected():
    assert True
  #+end_src
- engine
  #+begin_src python
def test_engine_functions_as_expected():
    assert True
  #+end_src
- entertainment
  #+begin_src python
def test_entertainment_functions_as_expected():
    assert True
  #+end_src

Then lets re-run pytest
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/ :results output
pytest -v
#+end_src

Now, we are able to run all the tests within a short amount of time. However, this is not the case always. Indeed, most of the time full test run of a test harnesses takes hours, even days. Therefore, as a developer, it will be improtant for you to run the test only related with the module that you make your development. For this purpose, we can use markers from ~pytest~. See below example


- body
  #+begin_src python
from pytest import mark


@mark.body
def test_body_functions_as_expected():
    assert True


@mark.smoke
@mark.body
def test_fundamental_body_functions_as_expected():
    assert True
  #+end_src
- engine
  #+begin_src python
from pytest import mark


@mark.engine
def test_engine_functions_as_expected():
    assert True


@mark.smoke
@mark.engine
def test_fundamental_engine_functions_as_expected():
    assert True
  #+end_src
- entertainment
  #+begin_src python
from pytest import mark


@mark.entertainment
def test_entertainment_functions_as_expected():
    assert True
  #+end_src

Then lets re-run pytest
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/ :results output
pytest -v
#+end_src


Then lets re-run pytest only for =engine= mark
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/ :results output
pytest -m engine -v
#+end_src

Notice that this will also generate a warning as given below:
#+begin_example
...
tests/sportscar/engine/test_engine.py:6: PytestUnknownMarkWarning: Unknown pytest.mark.engine - is this a typo?  You can register custom marks to avoid this warning - for details, see https://docs.pytest.org/en/stable/how-to/mark.html
    @mark.engine
...
#+end_example

This is caused since we haven't register this marker explicitly. To avoid this warning, lets add following lines to =pytest.ini= file (see [[https://docs.pytest.org/en/stable/how-to/mark.html][details]]). When you re-run ~pytest -m engine -v~, you will notice that warning is disappeared.
#+name: pytest-ini-with-markers
#+begin_src toml
markers =
    engine: marks tests related with engine (select with '-m "engine"')
    body: marks tests related with body (select with '-m "body"')
    entertainment: marks tests related with entertainment (select with '-m "entertainment"')
    smoke: marks tests related with fundamental funcitonalities (select with '-m "smoke"')
#+end_src


I believe you also notice that body and engine tests are marked with smoke, so that we can run all the smoke test via ~pytest -m smoke~ . Even further, we can just run the smoke test only related with engine
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/ :results output
pytest -m "engine and smoke" -v
#+end_src

- *OR*
  - ~pytest -m "not entertainment" -v~, run all the tests other than the entertainment suite
  - ~pytest -m "engine or smoke" -v~, run all the tests either related with engine or smoke suite
  - ~pytest -m "smoke and not body" -v~, run all the tests both related with smoke suite, but not inside body suite
  - ~pytest -m "not engine or smoke" -v~, un all the tests either not inside engine suite or within smoke suite.

As you can see, with the markers we are able to generate ou own custom suites just with simple parameters. So, pytest provides us simple and self maintaining system for suites. If you want to remove one of the test from smoke suite you can just remove the marker.

However, it has started to be hard to mark every single function with a marker. To overcome this, we can just mark the class and put the tests inside it. Lets do it with creating a new suite called battery suite.

Add following line to ~pytest.ini~ file
#+begin_src toml
    battery: marks tests related with battery (select with '-m "battery"')
#+end_src

and create following test class
#+begin_src python
from pytest import mark


@mark.battery
class BatteryTests:
    @mark.smoke
    def test_fundamental_battery_functions_as_expected(self):
        assert True


    def test_battery_functions_as_expected(self):
        assert True

#+end_src

Now, lets test our new suite
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/ :results output
pytest -m "battery or smoke" -v
#+end_src

One final point is that, to list all the markers use ~pytest --markers~ (see ~pytest -h~ for further details)

** Save Time and Code with Test Fixtures

Okay lets say that we need to read the serial number of a car from a certain file before each test, and ensure that it is in a certain format. A sample file is given below:
#+begin_src text :tangle ~/venvs/frameworkenv/sample_file.txt
Some text SerialNumber=123456789
#+end_src

To parse this, we can use ~re~ package. However, writing those statements for each test will create a significant amout of code duplication, and maintanance cost.
#+begin_src python :results output
import re

with open('sample_file.txt', 'r') as file:
    sample_string = file.read()

# Define the regex pattern to match MAC addresses
pattern = r"SerialNumber=[0-9]+"

# Find all matches of the pattern in the string
matches = re.findall(pattern, sample_string)

# Extract MAC addresses from matches
serial_number = [match.split('=')[1] for match in matches]
print(serail_number[0])
#+end_src

To aviod this problem, we can use ~fixtures~, and ~fixtures~ are just a function used to avoid code duplicaitions. To make our fixture available to all the test cases, we should create it under =conftest.py=, which stands for /configure test/. So that, any fixture that we create in =conftest.py= becomes accessible anywhere inside that directory and any directory below it, any test case that is in that directory or any test case below it. Therefore, I will create =conftest.py= file under =tests= directory.

#+begin_src python :tangle ~/venvs/frameworkenv/tests/conftest.py
from pytest import fixture
import re


# function is the default scope
@fixture(scope='module')
def serial_number_from_file():
    with open('sample_file.txt', 'r') as file:
        sample_string = file.read()

    # Define the regex pattern to match MAC addresses
    pattern = r"SerialNumber=[0-9]+"

    # Find all matches of the pattern in the string
    matches = re.findall(pattern, sample_string)

    # Extract MAC addresses from matches
    serial_number = [match.split('=')[1] for match in matches]
    return serial_number

#+end_src

Here is a one important point to be aware of return value of fixtures have scopes, and there are 3 different scope option:
- ~function~: Returned object will be available through the functions scope and for multiple calls fixture will not be evaluated again. This also means that if I modify this value with the first usage inside the function, this change will be available in the remainin of function (Not much different from a variable).
- ~module~: Returned object will be available through the file scope and for multiple calls fixture will not be evaluated again throughout the test file. This also means that if I modify this value in first body test, this change will be available to body tests coming after it.
- ~session~: Returned object will be available through the test run and for multiple calls fixture will not be evaluated again throughout the test session. This also means that if I modify this value in body test, this change will be available to tests run after it.

Lets update file contents as below:
- =pytest.ini=
  #+begin_src toml :tangle ~/venvs/frameworkenv/pytest.ini
[pytest]
python_files = test_*
python_classes = *Tests
python_functions = test_*

markers =
    engine: marks tests related with engine (select with '-m "engine"')
    body: marks tests related with body (select with '-m "body"')
    entertainment: marks tests related with entertainment (select with '-m "entertainment"')
    smoke: marks tests related with fundamental funcitonalities (select with '-m "smoke"')
    battery: marks tests related with battery (select with '-m "battery"')
  #+end_src
- body
  #+begin_src python :tangle ~/venvs/frameworkenv/tests/sportscar/body/test_body.py
from pytest import mark


@mark.body
def test_body_functions_as_expected():
    assert True


@mark.smoke
@mark.body
def test_fundamental_body_functions_as_expected(serial_number_from_file):
    print()
    serial_number = serial_number_from_file
    print("initial value", serial_number)
    serial_number.append("hello")
    print("value after append", serial_number)
    assert False
  #+end_src
- engine
  #+begin_src python :tangle ~/venvs/frameworkenv/tests/sportscar/engine/test_engine.py
from pytest import mark


@mark.engine
def test_engine_functions_as_expected():
    assert True


@mark.smoke
@mark.engine
def test_fundamental_engine_functions_as_expected(serial_number_from_file):
    print()
    serial_number = serial_number_from_file
    print("initial value", serial_number)
    serial_number.append("hello")
    print("value after append", serial_number)
    assert True
  #+end_src
- entertainment
  #+begin_src python :tangle ~/venvs/frameworkenv/tests/sportscar/entertainment/test_entertainment.py
from pytest import mark


@mark.entertainment
def test_entertainment_functions_as_expected(serial_number_from_file):
    print()
    serial_number = serial_number_from_file
    print("initial value", serial_number)
    serial_number.append("hello")
    print("value after append", serial_number)
    assert True
  #+end_src
- battery
  #+begin_src python :tangle ~/venvs/frameworkenv/tests/sportscar/battery/test_battery.py
from pytest import mark


@mark.battery
class BatteryTests:
    @mark.smoke
    def test_fundamental_battery_functions_as_expected(self, serial_number_from_file):
        print()
        serial_number = serial_number_from_file
        print("initial value", serial_number)
        serial_number.append("hello")
        print("value after append", serial_number)
        assert True

    @mark.smoke
    def test_other_fundamental_battery_functions_as_expected(self, serial_number_from_file):
        print()
        serial_number = serial_number_from_file
        print("initial value", serial_number)
        serial_number.append("hello")
        print("value after append", serial_number)
        assert True

    def test_battery_functions_as_expected(self):
        assert True
  #+end_src

Since the current scope is limitted to function calls. You will see that each function that is using the fixture will repeat following pattern:
#+begin_example
initial value ['123456789']
value after append ['123456789', 'hello']
#+end_example

Lets run the tests, in this point *do not forget to add ~-s~ option to see the print logs*:
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/ :results output
pytest -m "smoke" -vs
#+end_src

To see the changes and differences for yourself, try different fixture scopes.


There is still one final point about the fixtures, which can also help you to understand the fixture scopes better. First update fixture as given below, and re-run the tests

#+begin_src python
from pytest import fixture
import re


# function is the default scope
@fixture(scope='module')
def serial_number_from_file():
    with open('sample_file.txt', 'r') as file:
        sample_string = file.read()

    # Define the regex pattern to match MAC addresses
    pattern = r"SerialNumber=[0-9]+"

    # Find all matches of the pattern in the string
    matches = re.findall(pattern, sample_string)

    # Extract MAC addresses from matches
    serial_number = [match.split('=')[1] for match in matches]
    print("\nFixture creted")
    yield serial_number
    print("\nFixture destroyed")
#+end_src

Sample output is given below:
#+begin_example
$ pytest -m "smoke" -vs
...
collected 8 items / 4 deselected / 4 selected

tests/sportscar/battery/test_battery.py::BatteryTests::test_fundamental_battery_functions_as_expected
Fixture creted

initial value ['123456789']
value after append ['123456789', 'hello']
PASSED
tests/sportscar/battery/test_battery.py::BatteryTests::test_other_fundamental_battery_functions_as_expected
initial value ['123456789', 'hello']
value after append ['123456789', 'hello', 'hello']
PASSED
Fixture destroyed

tests/sportscar/body/test_body.py::test_fundamental_body_functions_as_expected
Fixture creted

initial value ['123456789']
value after append ['123456789', 'hello']
PASSED
Fixture destroyed

tests/sportscar/engine/test_engine.py::test_fundamental_engine_functions_as_expected
Fixture creted

initial value ['123456789']
value after append ['123456789', 'hello']
PASSED
Fixture destroyed


========================================== 4 passed, 4 deselected in 0.02s ==========================================
#+end_example

** Basics of Test Results Reporting and Tracking Test History
One of the best way to represent the test results is to use html/xml.

In that point, it is good to point out again that while organising your tests please use ~tests/<module>/<class>::<function>~ structure while organising your tests. So that, you will notice how descriptive test names can be.

*** HTML
To achieve such test output in pytest, one can use ~pytest-html~ library. To install it use ~python -m pip install pytest-html~, and to grasp the results you can run pytest as given below:
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/ :results output
pytest -v --html="results.html"
#+end_src

*Be careful that, if you use ~-s~ option to see the prints. Pytest will not be able to catch any test logs.*

This can also be useful to add some customization on this report, such as
- test suite/harness version, and current commit hash
- exporting the test results in other test output formats
- Format of html can be improved


*** XML
This output formating already comes with ~pytest~ by deafult. This is also one of the most commonly used test output formating, thanks to ~Junit~ framework. Lets run and see:
#+begin_src shell :shebang #!/usr/bin/env bash :dir ~/venvs/frameworkenv/ :results output
pytest -v --junitxml="results.xml"
#+end_src

/The good side of xml output is that it can be used to keep track of test history in jenkins./

** Customizing Test Runs with the Command Line and Configuration Files
** Handling Skips and Expected Failures
** Cross-Browser and Data-driven testing with parametrize
** Fast Testing with Pytest-xdist, and Parallel vs Concurrent
** Writing Unit Tests (White Box Testing) with Tox
** Writing Functional Tests (Black/Grey Box Testing)
